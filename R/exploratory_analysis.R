
##' @title Empirical variogram
##' @description Computes the empirical variogram using ``bins'' of distance provided by the user.
##' @param data an object of class \code{sf} containing the variable for which the variogram
##' is to be computed and the coordinates
##' @param variable a character indicating the name of variable for which the variogram is to be computed.
##' @param bins a vector indicating the `bins` to be used to define the classes of distance used in the computation of the variogram.
##' By default \code{bins=NULL} and bins are then computed as \code{seq(0, d_max/2, length=15)} where \code{d_max} is the maximum distance observed in the data.
##' @param n_permutation a non-negative integer indicating the number of permutation used to compute the 95% confidence
##' level envelope under the assumption of spatial independence. By default \code{n_permutation=0}, and no envelope is generated.
##'
##' @return an object of class 'variogram' which is a list containing the following components
##' @return \code{dist_class} the classes of distances based on the provided values for \code{bins}
##' @return \code{v} the variogram values
##' @return \code{n} the number of pairs of observations within each bin
##' @return \code{mid_points} the middle points of the classes of distance.
##' @return \code{lower_bound} the lower values of the 95% envelope generated by the random permutations of the variogram values (if \code{n_permutation=0} this component is \code{NULL}).
##' @return \code{upper_bound} the upper values of the 95% envelope generated by the random permutations of the variogram values (if \code{n_permutation=0} this component is \code{NULL}).
##' @author Emanuele Giorgi \email{e.giorgi@@lancaster.ac.uk}
##' @author Claudio Fronterre \email{c.fronterr@@lancaster.ac.uk}
##' @export
##'

s_variogram <- function(data, variable, bins = NULL,
                      n_permutation = 0,
                      convert_to_utm = TRUE,
                      scale_to_km = FALSE) {

  if(n_permutation < 0 |
     n_permutation != round(n_permutation)) stop("n_permutation must be a positive integer number")

  if(!convert_to_utm) cat("The distances of the variogram are computed assuming
                          that the CRS of the data gives distances in meters or kilometers")
  data <- st_transform(data, crs = 4326)
  data <- st_transform(data, crs = propose_utm(data))
  coords <- st_coordinates(data)
  d <- as.numeric(dist(coords))
  if(scale_to_km) d <- d/1000
  v <- (as.numeric(dist(data[[variable]])) ^ 2) / 2
  vario_df <- tibble(d, v)
  if(is.null(bins)) {
    max.v <- max(d)
    bins <- seq(0, max.v, length=15)
  } else {
    max.v <- max(bins)
  }
  if(max.v > max(d)) stop("the provided distances in 'bins' go beyond
                          the maximum observed distance")
  mid_points <- bins[-length(bins)] + (bins[2] - bins[1]) / 2

  vario_df <- vario_df[vario_df$d < max.v,]
  if(nrow(vario_df)==0) stop("the values provided in 'bins' do not match the
  scale of the obsererved distances; consider setting scale_to_km = TRUE")
  vario_df$dist_class <- cut(vario_df$d, breaks = bins,
                             include.lowest = TRUE, right = TRUE)
  aggregate(v ~ dist_class, data = vario_df, FUN = mean)
  vario_df <- vario_df %>%
      group_by(dist_class) %>%
      summarise(v = mean(v), n = n()) %>%
      mutate(mid_points = mid_points)


  if(n_permutation > 0) {
    v_perm <- matrix(NA, nrow=nrow(vario_df),ncol = n_permutation)
    for(i in 1:n_permutation) {
      v_i <- sample(v)

      vario_df_i <- tibble(d, v_i)

      vario_df_i$dist_class <- cut(vario_df_i$d, breaks = bins,
                                   include.lowest = TRUE, right = TRUE)

      v_perm[,i] <- aggregate(v_i ~ dist_class, data = vario_df_i, FUN = mean)$v_i
    }
    vario_df$lower_bound <- apply(v_perm, 1, function(x) quantile(x, 0.025))
    vario_df$upper_bound <- apply(v_perm, 1, function(x) quantile(x, 0.975))
  }
  vario_df$scale_to_km <- scale_to_km
  class(vario_df) <- "variogram"
  return(vario_df)
}
